# System configuration
units metal
dimension 3
boundary p p f
atom_style atomic
timestep {{ simulation.timesteps_size }}

# Output directory setup
variable output_directory string "{{ simulation.output_directory }}"
shell mkdir ${output_directory}

# Frequency used for trajectory.lammpstrj and nanoparticle_trajectory.lammpstrj
variable dump_frequency equal {{ simulation.dump_frequency }}

# Used for center_symmmetric_dump, cna_dump, vonmises_dump
# tempereature_related_dump, energy_dump
variable analysis_related_dump_frequency equal {{ simulation.analysis_dump_frequency }}

package gpu 1 neigh yes split 1.0 binsize 2.8

# Simulation box 
lattice fcc {{ system.material.lattice }}
region simulation_box block {{ system.box_dimensions[0] }} {{ system.box_dimensions[1] }} {{ system.box_dimensions[2] }} {{ system.box_dimensions[3] }} {{ system.box_dimensions[4] }} {{ system.box_dimensions[5] }}
create_box 1 simulation_box

# Mass for Cu
mass 1 {{ system.material.mass }}

# Lower plane
region lower_plane block {{ regions.lower_plane[0] }} {{ regions.lower_plane[1] }} {{ regions.lower_plane[2] }} {{ regions.lower_plane[3] }} {{ regions.lower_plane[4] }} {{ regions.lower_plane[5] }}
create_atoms 1 region lower_plane

# Upper plane 
region upper_plane block {{ regions.upper_plane[0] }} {{ regions.upper_plane[1] }} {{ regions.upper_plane[2] }} {{ regions.upper_plane[3] }} {{ regions.upper_plane[4] }} {{ regions.upper_plane[5] }}
create_atoms 1 region upper_plane

# Nanoparticle
region nanoparticle sphere {{ regions.nanoparticle[0] }} {{ regions.nanoparticle[1] }} {{ regions.nanoparticle[2] }} {{ regions.nanoparticle[3] }}
create_atoms 1 region nanoparticle

# Groups
group lower_plane_group region lower_plane
group nanoparticle_group region nanoparticle
group upper_plane_group region upper_plane
group mobile_group subtract all lower_plane_group upper_plane_group

# EAM potentials
pair_style eam/gpu
pair_coeff * * {{ system.material.potential }}

neigh_modify delay {{ neighbor.delay }} every {{ neighbor.every }} check {{ neighbor.check }} page {{ neighbor.page }} one {{ neighbor.one }} binsize {{ neighbor.binsize }}
delete_atoms overlap 0.01 nanoparticle_group upper_plane_group

# Save nanoparticle IDs and initial positions
dump nanoparticle_init nanoparticle_group custom 1 ${output_directory}/nanoparticle_init.txt id type x y z
run 0
undump nanoparticle_init

# Create bottom plane subgroups, only fix the lowest layer
region bottom_layer block {{ regions.lower_plane[0] }} {{ regions.lower_plane[1] }} {{ regions.lower_plane[2] }} {{ regions.lower_plane[3] }} 0 1.0
group fixed_bottom_layer region bottom_layer
group flexible_bottom_layer subtract lower_plane_group fixed_bottom_layer

# Fix only the lowest layer of the bottom plane
fix hold_bottom_layer fixed_bottom_layer setforce 0.0 0.0 0.0

# Computers for friction (sum of fx on upper planes)
compute fx_upper_plane upper_plane_group reduce sum fx
variable fx_upper_plane equal c_fx_upper_plane

# Computes for energy and temperature (mobile_group atoms)
compute ke_mobile mobile_group ke/atom
compute pe_mobile mobile_group pe/atom
compute temp_mobile mobile_group temp
compute disp_nanoparticle nanoparticle_group displace/atom

# Dump
# dump 1 all custom ${dump_frequency} ${output_directory}/trajectory.lammpstrj id type x y z fx fy fz

# Trace the trajectory of the nanoparticle during the simulation
# dump nanoparticle_trajectory nanoparticle_group custom ${dump_frequency} ${output_directory}/nanoparticle_trajectory.lammpstrj id type x y z c_disp_nanoparticle[*]

# Thermostat 
fix thermostat_upper upper_plane_group langevin {{ dynamics.thermostat.upper_plane.temperature }} {{ dynamics.thermostat.upper_plane.temperature }} {{ dynamics.thermostat.upper_plane.damping }} {{ dynamics.thermostat.upper_plane.seed }}

# Allow the lower plane to dissipate the heat generated by friction.
fix thermostat_lower lower_plane_group langevin {{ dynamics.thermostat.lower_plane.temperature }} {{ dynamics.thermostat.lower_plane.temperature }} {{ dynamics.thermostat.lower_plane.damping }} {{ dynamics.thermostat.lower_plane.seed }}

# In real-life experiments, planes can absorb and dissipate heat
fix nve_mobile mobile_group nve

# A soft thermostat for the nanoparticle prevents localized overheating
fix thermo_nano nanoparticle_group langevin {{ dynamics.thermostat.nanoparticle.temperature }} {{ dynamics.thermostat.nanoparticle.temperature }} {{ dynamics.thermostat.nanoparticle.damping }} {{ dynamics.thermostat.nanoparticle.seed }}

# Initial position tracking for upper plane
variable initial_z_upper equal xcm(upper_plane_group,z)
variable current_z_upper equal ${initial_z_upper}

# Parameters for approach - adjust for precision vs. speed
variable approach_rate equal {{ simulation.approach_rate }}
variable displace_increment equal ${approach_rate}

# Setup for force monitoring only
compute normal_force_nanoparticle_upper_plane nanoparticle_group group/group upper_plane_group
variable fz equal c_normal_force_nanoparticle_upper_plane[3]
variable prev_fz equal 0.0
variable fz_change equal 0.0

# Debug output
fix debug_approach all print 100 "Step $(step): Fz = ${fz} eV/A, Fz_change = ${fz_change}, Z = ${current_z_upper}"

run 0
variable prev_fz equal ${fz}

# Approach loop using displace/atoms with automatic contact detection based on force rate of change
label loop_approach
  # Displace the upper plane atoms down by the increment
  displace_atoms upper_plane_group move 0.0 0.0 -${displace_increment}
  
  # Update current position
  variable current_z_upper equal xcm(upper_plane_group,z)
  
  # Run a short simulation to let the system adjust
  run {{ approach.relaxation_steps }}
  
  # Calculate change in force for contact detection
  variable fz_change equal abs((${fz} - ${prev_fz})/${displace_increment})
  variable prev_fz equal ${fz}
  
  # Detect contact based on significant change in force rate
  # When the force changes rapidly, contact is happening
  # Start with a small value and adjust if needed
  variable contact_detected equal ${fz_change} > 0.2
  
  # Alternative: use a combined criterion
  # variable contact_detected equal (${fz_change} > 0.2) || (abs(${fz}) > 0.5)
  
  # Continue loop if contact not detected
  if ${contact_detected}==0 then "jump SELF loop_approach"

# Clean up
unfix debug_approach

# Record contact force
variable fz_contact equal ${fz}
variable normal_load equal ${fz_contact}
print "Contact Detected: Fz = ${fz_contact} eV/Angstrom at Z position = ${current_z_upper}, Fz change = ${fz_change}"
fix contact_out all print 1 "${fz_contact}" file ${output_directory}/contact_force.txt screen no

# Apply constant normal force using addforce
fix normal_load upper_plane_group addforce 0.0 0.0 -${normal_load}

# Continue with your oscillatory movement for friction study
fix move_upper_plane upper_plane_group move variable v_x_pos v_y_pos v_z_pos NULL NULL NULL

variable fz_nanoparticle_upper_plane equal c_normal_force_nanoparticle_upper_plane[3]
variable fx_nanoparticle_upper_plane equal c_normal_force_nanoparticle_upper_plane[1]

# Oscillatory motion (fretting) for the upper plane
variable amplitude equal {{ dynamics.oscillation.amplitude }}
variable period equal {{ dynamics.oscillation.period }}
variable omega equal 2.0*PI/v_period
variable damp_factor equal {{ dynamics.oscillation.damping }}
variable x_pos equal v_amplitude*sin(v_omega*step)*(1-v_damp_factor*sin(v_omega*step)*sin(v_omega*step))
variable y_pos equal 0.0
variable z_pos equal 0.0

# Localized and cyclical wear:
fix move_upper_plane upper_plane_group move variable v_x_pos v_y_pos v_z_pos NULL NULL NULL

# Z average position for upper plane
compute z_upper_plane upper_plane_group reduce ave z
variable z_upper_plane equal c_z_upper_plane

# Calculate coefficient of friction using the detected contact force
variable abs_fz equal abs(v_fz_nanoparticle_upper_plane)
variable fz_diff equal v_abs_fz-v_normal_load
variable shift equal 0.5*v_fz_diff+sqrt(v_fz_diff*v_fz_diff*0.25+0.0001)
variable fz_safe equal v_normal_load+v_shift
variable coefficient_friction equal abs(v_fx_nanoparticle_upper_plane / v_fz_safe)

# Upper limit to avoid extreme peaks
variable coef_diff equal v_coefficient_friction-1.0
variable coef_shift equal 0.5*(v_coef_diff+sqrt(v_coef_diff*v_coef_diff+0.0001))
variable coefficient_friction_capped equal v_coefficient_friction-v_coef_shift

fix friction_output all ave/time 100 10 1000 v_coefficient_friction v_coefficient_friction_capped file ${output_directory}/friction_data.txt

# Identify structural defects (direct indicator of wear)
compute center_symmetric all centro/atom 12
# dump center_symmetric_dump all custom ${analysis_related_dump_frequency} ${output_directory}/center_symmetric.dump id type x y z c_center_symmetric

variable deformation_threshold equal {{ thresholds.deformation }}
compute center_symmetric_sumsq all reduce sumsq c_center_symmetric

compute center_symmetric_average all reduce ave c_center_symmetric
variable center_symmetric_sum equal c_center_symmetric_average*count(all)
variable total_struct_atoms equal count(all)
variable center_symmetric_std equal sqrt(c_center_symmetric_sumsq/v_total_struct_atoms - c_center_symmetric_average * c_center_symmetric_average)
variable defect_percent equal 100.0*(c_center_symmetric_average/v_deformation_threshold)

# Common Neighbor Analysis (CNA)
group cna_group subtract all lower_plane_group upper_plane_group

compute cna cna_group cna/atom {{ thresholds.cna_cutoff }}
# dump cna_dump all custom ${analysis_related_dump_frequency} ${output_directory}/cna.dump id type x y z c_cna

# Von mises stress calculation
compute vonmises all stress/atom NULL
variable atoms_stress atom sqrt((c_vonmises[1]-c_vonmises[2])*(c_vonmises[1]-c_vonmises[2])+(c_vonmises[2]-c_vonmises[3])*(c_vonmises[2]-c_vonmises[3])+(c_vonmises[3]-c_vonmises[1])*(c_vonmises[3]-c_vonmises[1])+6.0*(c_vonmises[4]*c_vonmises[4]+c_vonmises[5]*c_vonmises[5]+c_vonmises[6]*c_vonmises[6]))/2.0
# dump vonmises_dump all custom ${analysis_related_dump_frequency} ${output_directory}/vonmises.dump id type x y z v_atoms_stress

# Analysis of the Squared Velocity Calculation
compute velocity_squared all property/atom vx vy vz
variable velocity_squared_atom atom (c_velocity_squared[1]*c_velocity_squared[1]+c_velocity_squared[2]*c_velocity_squared[2]+c_velocity_squared[3]*c_velocity_squared[3])
# dump temperature_related_dump all custom ${analysis_related_dump_frequency} ${output_directory}/velocity_squared.dump id type x y z v_velocity_squared_atom

# Identify and monitor the fragments (debris)
compute cluster all cluster/atom {{ thresholds.cluster_cutoff }}
# dump debris_dump all custom ${analysis_related_dump_frequency} ${output_directory}/debris_clusters.dump id type x y z c_cluster

# Calculate and save the total energy per atom for the mobile group
variable total_energy atom c_ke_mobile+c_pe_mobile
# dump energy_dump mobile_group custom ${analysis_related_dump_frequency} ${output_directory}/energy.dump id type x y z c_ke_mobile c_pe_mobile v_total_energy

# Monitor the number of atoms in the nanoparticle cluster over time
variable contact_count equal "count(nanoparticle_group)"
fix contact_monitor all ave/time {{ simulation.thermo_frequency }} 1 {{ simulation.thermo_frequency }} v_contact_count file ${output_directory}/contact_count.txt

# Radial Distribution Function (RDF) for analyzing atomic structure
compute radial_distribution_function all rdf 100 1 1
fix radial_distribution_function_output all ave/time 5000 1 5000 c_radial_distribution_function[*] file ${output_directory}/radial_distribution_function_output.txt mode vector

# Calculate the average and maximum values of the central symmetry parameter
compute center_symmetric_max all reduce max c_center_symmetric

# Calculate average and maximum values for von Mises stress values
compute vonmises_average all reduce ave v_atoms_stress
compute vonmises_max all reduce max v_atoms_stress

# Calculation of the specific temperature of the nanoparticle
compute velocity_squared_nanoparticle_average nanoparticle_group reduce ave v_velocity_squared_atom
variable nanoparticle_temperature equal c_velocity_squared_nanoparticle_average*25.464

# Periodically record indicators related to nanoparticle wear
fix wear_monitor all ave/time {{ simulation.thermo_frequency }} 1 {{ simulation.thermo_frequency }} c_center_symmetric_average c_center_symmetric_max c_vonmises_average c_vonmises_max v_nanoparticle_temperature v_contact_count v_defect_percent file ${output_directory}/wear_data.txt

# Material Transfer Analysis between Top and Bottom Surfaces
group initial_lower_group region lower_plane
group initial_upper_group region upper_plane

group current_lower_group dynamic all region lower_plane every 5000
group current_upper_group dynamic all region upper_plane every 5000

variable transferred_to_lower_group equal count(current_lower_group)-count(initial_lower_group)
variable transferred_to_upper_group equal count(current_upper_group)-count(initial_upper_group)

fix material_transfer all ave/time 5000 1 5000 v_transferred_to_lower_group v_transferred_to_upper_group file ${output_directory}/material_transfer.txt

# Identify hot spots caused by friction, impact, and deformation
compute ke_hotspots all ke/atom
variable hot_threshold equal "{{ thresholds.hotspot_factor }}*8.617e-5*{{ system.temperature }}"
variable is_hotspot atom "c_ke_hotspots > v_hot_threshold"
compute hotspots_count all reduce sum v_is_hotspot
fix hotspot_monitor all ave/time {{ simulation.thermo_frequency }} 1 {{ simulation.thermo_frequency }} c_hotspots_count file ${output_directory}/hotspots_count.txt

# Dump para visualizar puntos calientes
# dump hotspots all custom ${analysis_related_dump_frequency} ${output_directory}/hotspots.dump id type x y z c_ke_hotspots v_is_hotspot

# Calculate the coordination number for each atom
compute coord all coord/atom cutoff {{ thresholds.coordination_cutoff }}
# dump coord_dump all custom ${analysis_related_dump_frequency} ${output_directory}/coordination.dump id type x y z c_coord

# Calculate statistics from coordination numbers
compute coord_avg all reduce ave c_coord
compute coord_min all reduce min c_coord
compute coord_max all reduce max c_coord
fix coord_stats all ave/time 5000 1 5000 c_coord_avg c_coord_min c_coord_max file ${output_directory}/coordination_stats.txt

# Trajectory visualization with structure identifiers using PTM
compute ptm all ptm/atom fcc {{ thresholds.ptm_cutoff }}
# dump ptm_dump all custom ${analysis_related_dump_frequency} ${output_directory}/ptm.dump id type x y z c_ptm[1] c_ptm[2] c_ptm[3] c_ptm[4] c_ptm[5] c_ptm[6]

dump main_dump all custom ${dump_frequency} ${output_directory}/trajectory.lammpstrj id type x y z fx fy fz
dump analysis_dump all custom ${analysis_related_dump_frequency} ${output_directory}/analysis.lammpstrj id type x y z &
    c_center_symmetric c_cna v_atoms_stress v_velocity_squared_atom c_cluster &
    c_ke_hotspots v_is_hotspot c_coord c_ptm[1] c_ptm[2] c_ptm[3] c_ptm[4] c_ptm[5] c_ptm[6] &
    c_ke_mobile c_pe_mobile v_total_energy

# dump energy_dump mobile_group custom ${analysis_related_dump_frequency} ${output_directory}/energy.dump id type x y z c_ke_mobile c_pe_mobile v_total_energy

# Output thermo information
thermo_style custom step time atoms &
    temp c_temp_mobile press etotal pe ke &
    v_fx_nanoparticle_upper_plane v_fz_nanoparticle_upper_plane &
    v_coefficient_friction c_center_symmetric_average

thermo {{ simulation.thermo_frequency }}

# Energy minimization (to relax initial structure)
thermo_modify lost ignore
min_style cg
minimize {{ run.minimization.etol }} {{ run.minimization.ftol }} 5000 50000

restart {{ simulation.restart_frequency }} ${output_directory}/restart.*.binary

# Run
run {{ run.production_steps }}