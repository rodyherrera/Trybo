# System configuration
units metal
dimension 3
boundary p p f
atom_style atomic
timestep 0.0001

# LAMMPS build with GPU cmake option
package gpu 1 neigh yes split 1.0 gpuID 0 tpa 64

suffix gpu

# Simulation box 
lattice fcc 3.615
region simulation_box block 0 25 0 25 0 25
create_box 1 simulation_box

# Mass for Cu
mass 1 63.546

# Lower plane
region lower_plane block 2.5 22.5 2.5 22.5 0 2.5
create_atoms 1 region lower_plane

# Upper plane 
region upper_plane block 2.5 22.5 2.5 22.5 22.5 25
create_atoms 1 region upper_plane

# Nanoparticle
region nanoparticle sphere 12.5 12.5 12.5 9.5
create_atoms 1 region nanoparticle

# Groups
group lower_plane_group region lower_plane
group nanoparticle_group region nanoparticle
group upper_plane_group region upper_plane
group mobile_group subtract all lower_plane_group upper_plane_group

# EAM potentials
pair_style eam/gpu
pair_coeff * * Cu_u3.eam

neigh_modify delay 2 every 1 check yes page 1000000 one 100000 binsize 2.5
delete_atoms overlap 0.01 nanoparticle_group upper_plane_group

# Save nanoparticle IDs and initial positions
dump nanoparticle_init nanoparticle_group custom 1 nanoparticle_init.txt id type x y z
run 0
undump nanoparticle_init

# Fix bottom plane
fix hold_lower_plane lower_plane_group setforce 0.0 0.0 0.0

# Computers for friction (sum of fx on upper planes)
compute fx_upper_plane upper_plane_group reduce sum fx
variable fx_upper_plane equal c_fx_upper_plane

# Computes for energy and temperature (mobile_group atoms)
compute ke_mobile mobile_group ke/atom
compute pe_mobile mobile_group pe/atom
compute temp_mobile mobile_group temp
compute disp_nanoparticle nanoparticle_group displace/atom

# Dump
dump 1 all custom 1000 trajectory.lammpstrj id type x y z fx fy fz

# Trace the trajectory of the nanoparticle during the simulation
dump nanoparticle_trajectory nanoparticle_group custom 1000 nanoparticle_trajectory.lammpstrj id type x y z c_disp_nanoparticle[*]

# Thermostat 
fix thermostat_upper upper_plane_group langevin 300 300 1.0 48279

# Allow the lower plane to dissipate the heat generated by friction.
# When the nanoparticle is rubbed between two planes, a large amount of frictional heat is generated.
# If no part of the system can dissipate this heat, the energy accumulates in the nanoparticle its temperature rises it can melt.
fix thermostat_lower lower_plane_group langevin 300 300 1.0 12345

# In real-life experiments, planes (or large surfaces) can absorb and 
# dissipate the heat generated by friction. Nanoparticles, on the other 
# hand, are typically much smaller and can heat up locally due to friction.
# If we apply a thermostat to the nanoparticle, the heat generated by 
# friction will be artificially removed, preventing you from observing 
# "frictional heating" and, therefore, thermal wear mechanisms.
fix nve_mobile mobile_group nve

# A soft thermostat for the nanoparticle prevents localized overheating. 
# Otherwise, all the energy generated by friction would accumulate within
# it, generating extremely high temperatures and unstable behavior. It also 
# helps dissipate heat in a realistic manner.
fix thermo_nano nanoparticle_group langevin 300 300 5.0 23456

# If the lower plane is completely fixed (setforce 0 0 0), it 
# is not necessary to thermostat it, but if it has some mobility, it is.
# fix thermo_lower lower_plane_group nvt temp 300 300 0.1

# Normal force to upper plane
# It is applied to the upper plane to simulate the pressure or 
# load that, in a real experiment, one surface exerts on another.
# Without normal force, the surfaces or nanoparticle barely touch,
# resulting in almost no or no friction. Many tribological properties, 
# such as coefficient of friction and wear, depend on normal loading.
#
# The value of the normal force can be detrimental to the pressure, as it can be 
# extremely high. However, in MD these pressures are common to accelerate the 
# processes. Experimentally, it is not realistic, but it is common to obtain 
# wear or friction in accessible times.
#
# A: It corresponds to the contact area, the 
# area in the XY plane where the upper plane and the nanoparticle make contact.
# A = (x max - x min) * (y max - y min)
# 
# P = Fz / A
variable Fz_normal equal -40.0
fix add_normal_force upper_plane_group addforce 0.0 0.0 ${Fz_normal}

# Oscillatory motion (fretting) for the upper plane
# physical period = period * timesteps = x ps
# frequency = 1/x ps = y THz
# 
# One must be careful not to set the frequency too high; however, in MD, 
# high frequencies are expected to be used to observe phenomena in simulatable 
# times. This is not realistic experimentally, but it is typical in MD.
variable amplitude equal 5.0
variable period equal 50000
variable omega equal 2.0*PI/v_period
variable damp_factor equal 0.2 
variable x_pos equal v_amplitude*sin(v_omega*step)*(1-v_damp_factor*sin(v_omega*step)*sin(v_omega*step))
variable y_pos equal 0.0
variable z_pos equal 0.0

# Movement for friction
# To study fretting wear it's okay to move 
# the plane in only one direction throughout the simulation.
# fix move_lower_plane lower_plane_group move linear -0.2 0.0 0.0 units box
# 
# Unidirectional and continuous wear:
# fix move_upper_plane upper_plane_group move linear 0.2 0.0 0.0 units box
#
# Localized and cyclical wear:
fix move_upper_plane upper_plane_group move variable v_x_pos v_y_pos v_z_pos NULL NULL NULL

# Z average position for upper plane
compute z_upper_plane upper_plane_group reduce ave z
variable z_upper_plane equal c_z_upper_plane

# Force measurement between nanoparticle and upper_plane
compute normal_force_nanoparticle_upper_plane nanoparticle_group group/group upper_plane_group
variable fz_nanoparticle_upper_plane equal c_normal_force_nanoparticle_upper_plane[3]

# Friction force measurement (x component)
variable fx_nanoparticle_upper_plane equal c_normal_force_nanoparticle_upper_plane[1]

# Calculate coefficient of friction
# When v_fz_nanoparticle_upper_Plane (normal force) approaches zero 
# during certain moments of the simulation, splitting produces astronomically 
# high values. For this reason, a minimum force threshold is set to avoid near-zero 
# splitting. This occurs when the nanoparticle temporarily loses contact with the 
# upper surface during the oscillatory motion.
# variable coefficient_friction equal abs(v_fx_nanoparticle_upper_plane / v_fz_nanoparticle_upper_plane)
variable fz_min equal 2.0
variable abs_fz equal abs(v_fz_nanoparticle_upper_plane)
variable fz_diff equal v_abs_fz-v_fz_min
variable shift equal 0.5*v_fz_diff+sqrt(v_fz_diff*v_fz_diff*0.25+0.0001)
variable fz_safe equal v_fz_min+v_shift
variable coefficient_friction equal abs(v_fx_nanoparticle_upper_plane / v_fz_safe)

# Upper limit to avoid extreme peaks
variable coef_diff equal v_coefficient_friction-1.0
variable coef_shift equal 0.5*(v_coef_diff+sqrt(v_coef_diff*v_coef_diff+0.0001))
variable coefficient_friction_capped equal v_coefficient_friction-v_coef_shift

fix friction_output all ave/time 100 10 1000 v_coefficient_friction v_coefficient_friction_capped file friction_data.txt

# Identify structural defects (direct indicator of wear)
# Statistical calculation of wear based on centro-symmetric
compute center_symmetric all centro/atom 12
dump center_symmetric_dump all custom 5000 center_symmetric.dump id type x y z c_center_symmetric

variable deformation_threshold equal 8.0
compute center_symmetric_sumsq all reduce sumsq c_center_symmetric

compute center_symmetric_average all reduce ave c_center_symmetric
variable center_symmetric_sum equal c_center_symmetric_average*count(all)
variable total_struct_atoms equal count(all)
variable center_symmetric_std equal sqrt(c_center_symmetric_sumsq/v_total_struct_atoms - c_center_symmetric_average * c_center_symmetric_average)
variable defect_percent equal 100.0*(c_center_symmetric_average/v_deformation_threshold)

# Common Neighbor Analysis (CNA)
# Helps identify crystalline regions, defects, grain boundaries, and phase transformations
# For FCC copper (first neighbor distance ~2.556 for network parameter 3.615)
group cna_group subtract all lower_plane_group upper_plane_group

# Uses a cutoff distance of 3.3 A to identify nearest neighbors
compute cna cna_group cna/atom 3.3
dump cna_dump all custom 5000 cna.dump id type x y z c_cna

# Von mises stress calculation
compute vonmises all stress/atom NULL
variable atoms_stress atom sqrt((c_vonmises[1]-c_vonmises[2])*(c_vonmises[1]-c_vonmises[2])+(c_vonmises[2]-c_vonmises[3])*(c_vonmises[2]-c_vonmises[3])+(c_vonmises[3]-c_vonmises[1])*(c_vonmises[3]-c_vonmises[1])+6.0*(c_vonmises[4]*c_vonmises[4]+c_vonmises[5]*c_vonmises[5]+c_vonmises[6]*c_vonmises[6]))/2.0
dump vonmises_dump all custom 2000 vonmises.dump id type x y z v_atoms_stress

# Analysis of the Squared Velocity Calculation for "hot spots" or regions of high kinetic energy in the system,
# energy transfer during processes such as friction, local thermal fluctuations during the simulation or
# non-uniform distribution of kinetic energy in the system.
compute velocity_squared all property/atom vx vy vz
variable velocity_squared_atom atom (c_velocity_squared[1]*c_velocity_squared[1]+c_velocity_squared[2]*c_velocity_squared[2]+c_velocity_squared[3]*c_velocity_squared[3])
dump temperature_related all custom 2000 velocity_squared.dump id type x y z v_velocity_squared_atom

# Calculate and save the total energy per atom for the mobile group
variable total_energy atom c_ke_mobile+c_pe_mobile
dump energy_dump mobile_group custom 2000 energy.dump id type x y z c_ke_mobile c_pe_mobile v_total_energy

# Monitor the number of atoms in the nanoparticle cluster over time
# We can monitor whether there is loss of atoms from the nanoparticle (wear), detect material transfer 
# between surfaces, quantify wear based on the number of atoms lost, etc.
variable contact_count equal "count(nanoparticle_group)"
fix contact_monitor all ave/time 1000 1 1000 v_contact_count file contact_count.txt

# Output thermo information: step, temperature, potential energy, friction force
thermo_style custom step temp press etotal pe ke v_fx_upper_plane v_z_upper_plane v_fz_nanoparticle_upper_plane v_fx_nanoparticle_upper_plane v_coefficient_friction v_coefficient_friction_capped
thermo 1000

# In molecular dynamics simulations, atoms can sometimes leave the 
# simulation box or disappear due to numerical errors or special configurations.
# By default, when this happens, LAMMPS may display warnings, stop the simulation, or generate errors.
# With thermo_modify lost ignore, LAMMPS simply ignores the loss of atoms when 
# calculating thermodynamic properties (such as temperature, energy, pressure, etc.) 
# and continues simulating without stopping.
thermo_modify lost ignore

# Energy minimization (to relax initial structure)
min_style cg
minimize 1e-6 1e-8 5000 50000

# System balancing
run 20000

# Reset files every 50,000 steps
restart 50000 restart.*.binary

# Run
run 1000000

print "OK"