# System configuration
units metal
dimension 3
boundary p p f
atom_style atomic

# LAMMPS build with GPU cmake option
package gpu 1

# Simulation box 
lattice fcc 3.615
region simulation_box block 0 50 0 50 0 50
create_box 1 simulation_box

# Mass for Cu
mass 1 63.546

# Lower plane
region lower_plane block 5 45 5 45 0 5
create_atoms 1 region lower_plane

# Nanoparticle
region nanoparticle sphere 25 25 25 19
create_atoms 1 region nanoparticle

# Upper plane
region upper_plane block 5 45 5 45 45 50
create_atoms 1 region upper_plane

# Groups
group lower_plane_group region lower_plane
group nanoparticle_group region nanoparticle
group upper_plane_group region upper_plane
group mobile_group subtract all lower_plane_group upper_plane_group

# Save nanoparticle IDs and initial positions
dump nanoparticle_init nanoparticle_group custom 1 nanoparticle_init.txt id type x y z
run 0
undump nanoparticle_init

# Fix bottom plane
fix hold_lower_plane lower_plane_group setforce 0.0 0.0 0.0

# Computers for friction (sum of fx on upper planes)
compute fx_upper_plane upper_plane_group reduce sum fx
variable fx_upper_plane equal c_fx_upper_plane

# Computes for energy and temperature (mobile_group atoms)
compute ke_mobile mobile_group ke/atom
compute pe_mobile mobile_group pe/atom
compute temp_mobile mobile_group temp
compute disp_nanoparticle nanoparticle_group displace/atom

# EAM potentials
pair_style eam/gpu
pair_coeff * * Cu_u3.eam

# Dump
dump 1 all custom 100 trajectory.lammpstrj id type x y z fx fy fz

# Trace the trajectory of the nanoparticle during the simulation
dump nanoparticle_trajectory nanoparticle_group custom 100 nanoparticle_trajectory.lammpstrj id type x y z c_disp_nanoparticle[*]

# Thermostat 
fix thermostat_upper upper_plane_group langevin 300 300 0.1 48279

# In real-life experiments, planes (or large surfaces) can absorb and 
# dissipate the heat generated by friction. Nanoparticles, on the other 
# hand, are typically much smaller and can heat up locally due to friction.
# If we apply a thermostat to the nanoparticle, the heat generated by 
# friction will be artificially removed, preventing you from observing 
# "frictional heating" and, therefore, thermal wear mechanisms.
# fix thermo_mobile mobile_group nvt temp 300 300 0.1

# If the lower plane is completely fixed (setforce 0 0 0), it 
# is not necessary to thermostat it, but if it has some mobility, it is.
# fix thermo_lower lower_plane_group nvt temp 300 300 0.1

# Normal force to upper plane
# It is applied to the upper plane to simulate the pressure or 
# load that, in a real experiment, one surface exerts on another.
# Without normal force, the surfaces or nanoparticle barely touch, 
# resulting in almost no or no friction. Many tribological properties, 
# such as coefficient of friction and wear, depend on normal loading.
variable Fz_normal equal -500.0
fix add_normal_force upper_plane_group addforce 0.0 0.0 ${Fz_normal}

# Movement for friction
fix move_upper_plane upper_plane_group move linear 0.2 0.0 0.0 units box

# Z average position for upper plane
compute z_upper_plane upper_plane_group reduce ave z
variable z_upper_plane equal c_z_upper_plane

# Force measurement between nanoparticle and upper_plane
compute normal_force_nanoparticle_upper_plane nanoparticle_group group/group upper_plane_group
variable fz_nanoparticle_upper_plane equal c_normal_force_nanoparticle_upper_plane[3]

# Friction force measurement (x component)
variable fx_nanoparticle_upper_plane equal c_normal_force_nanoparticle_upper_plane[1]

# Calculate coefficient of friction
variable coefficient_friction equal abs(v_fx_nanoparticle_upper_plane / v_fz_nanoparticle_upper_plane)

# Output thermo information: step, temperature, potential energy, friction force
thermo_style custom step temp press etotal pe ke v_fx_upper_plane v_z_upper_plane v_fz_nanoparticle_upper_plane v_fx_nanoparticle_upper_plane v_coefficient_friction
thermo 100

# In molecular dynamics simulations, atoms can sometimes leave the 
# simulation box or disappear due to numerical errors or special configurations.
# By default, when this happens, LAMMPS may display warnings, stop the simulation, or generate errors.
# With thermo_modify lost ignore, LAMMPS simply ignores the loss of atoms when 
# calculating thermodynamic properties (such as temperature, energy, pressure, etc.) 
# and continues simulating without stopping.
thermo_modify lost ignore

# Energy minimization (to relax initial structure)
min_style cg
minimize 1e-4 1e-6 1000 10000

# System balancing
run 5000

# Run
run 100000

print "OK"